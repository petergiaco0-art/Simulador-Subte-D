# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wzW_S5_r94o315RR-ubQgmmND3Lod6i9
"""

import streamlit as st
import pandas as pd
import numpy as np
import simpy
import random
import csv
import matplotlib.pyplot as plt
import scipy.stats as stats # <-- (NUEVA IMPORTACI√ìN)

# --- 0. CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(
    page_title="Simulador Subte L√≠nea D",
    layout="wide"
)

# --- URL de Datos (Reemplazar con tu link de Release) ---
DATA_URL = "https://github.com/petergiaco0-art/Simulador-Subte-D/releases/download/v1.0/202501_D.csv"

# --- 1. FUNCIONES DE CARGA Y DATOS ---

@st.cache_data
def load_and_clean_data(url_de_datos):
    st.info(f"Descargando y procesando datos de demanda (Enero)...")
    print("Iniciando descarga y limpieza de datos...")

    # --- Carga de Datos ---
    try:
        df = pd.read_csv(
            url_de_datos, sep=';', encoding='utf-8-sig',
            quoting=csv.QUOTE_NONE, low_memory=False
        )
    except Exception as e:
        st.error(f"Error fatal al leer el CSV desde la URL: {e}")
        return None

    # --- Limpieza (Id√©ntica a antes) ---
    df.columns = df.columns.str.replace('"', '', regex=False).str.strip()
    required_cols = ['FECHA', 'pax_TOTAL', 'ESTACION', 'LINEA', 'MOLINETE', 'DESDE']
    if not all(col in df.columns for col in required_cols):
        st.error(f"Error: El CSV no contiene todas las columnas requeridas: {required_cols}")
        return None
    df['FECHA'] = df['FECHA'].astype(str).str.replace('"', '', regex=False).str.strip()
    df['pax_TOTAL'] = df['pax_TOTAL'].astype(str).str.replace('"', '', regex=False).str.strip()
    df['LINEA'] = df['LINEA'].astype(str).str.strip()
    df['ESTACION'] = df['ESTACION'].astype(str).str.strip()
    df_linea_d = df[df['LINEA'] == 'LineaD'].copy()
    df_linea_d['ESTACION'] = df_linea_d['ESTACION'].replace('9 de julio', '9 de Julio')
    df_linea_d['ESTACION'] = df_linea_d['ESTACION'].replace('Ag√É¬ºero', 'Ag√ºero')
    df_linea_d['FECHA'] = pd.to_datetime(df_linea_d['FECHA'], format='%d/%m/%Y')
    df_linea_d['pax_TOTAL'] = pd.to_numeric(df_linea_d['pax_TOTAL'], errors='coerce')
    df_linea_d.dropna(subset=['pax_TOTAL'], inplace=True)
    df_linea_d['pax_TOTAL'] = df_linea_d['pax_TOTAL'].astype(int)

    print("Carga y limpieza de datos completada.")

    # --- C√°lculo de Lambda (Id√©ntico a antes) ---
    print("Iniciando c√°lculo de Lambda...")
    df_linea_d['DIRECCION'] = df_linea_d.apply(asignar_direccion, axis=1)
    df_con_direccion = df_linea_d[df_linea_d['DIRECCION'] != 'Ponderar'].copy()
    df_para_ponderar = df_linea_d[df_linea_d['DIRECCION'] == 'Ponderar'].copy()
    df_ponderar_catedral = df_para_ponderar.copy()
    df_ponderar_congreso = df_para_ponderar.copy()
    df_ponderar_catedral['DIRECCION'] = 'Hacia Catedral'
    df_ponderar_catedral['pax_TOTAL'] = df_ponderar_catedral['pax_TOTAL'] * 0.5
    df_ponderar_congreso['DIRECCION'] = 'Hacia Congreso'
    df_ponderar_congreso['pax_TOTAL'] = df_ponderar_congreso['pax_TOTAL'] * 0.5
    df_direccional = pd.concat([df_con_direccion, df_ponderar_catedral, df_ponderar_congreso], ignore_index=True)
    df_direccional['pax_TOTAL'] = pd.to_numeric(df_direccional['pax_TOTAL'], errors='coerce')
    df_direccional.dropna(subset=['pax_TOTAL'], inplace=True)
    condicion_pico_1hr = (df_direccional['DESDE'] >= '08:00:00') & (df_direccional['DESDE'] < '09:00:00')
    df_pico_direccional = df_direccional[condicion_pico_1hr].copy()
    df_lambda_final = df_pico_direccional.groupby(
        ['ESTACION', 'DIRECCION', 'DESDE']
    )['pax_TOTAL'].mean().reset_index()
    df_lambda_final = df_lambda_final.rename(columns={'pax_TOTAL': 'pasajeros_PROMEDIO_lambda'})
    print("C√°lculo de Lambda completado.")

    return df_lambda_final

# (Funci√≥n 'asignar_direccion' id√©ntica)
def asignar_direccion(row):
    estacion = row['ESTACION']
    molinete = str(row['MOLINETE'])
    if estacion == 'Catedral': return 'Hacia Congreso'
    if estacion == 'Congreso de Tucuman': return 'Hacia Catedral'
    if estacion == '9 de Julio': return 'Ponderar'
    if '_N_' in molinete: return 'Hacia Congreso'
    if '_S_' in molinete or '_SO_' in molinete: return 'Hacia Catedral'
    if '_Este_' in molinete or '_E_' in molinete: return 'Hacia Catedral'
    if '_Oeste_' in molinete or '_O_' in molinete: return 'Hacia Congreso'
    return 'Ponderar'

# --- 2. COMPONENTES DEL MODELO SIMPY ---
# (CONSTANTES, Clase Anden, Procesos: id√©nticos a antes)

LISTA_ESTACIONES_NORTE = [
    'Catedral', '9 de Julio', 'Tribunales', 'Callao', 'Facultad de Medicina',
    'Ag√ºero', 'Pueyrredon.D', 'Bulnes', 'Plaza Italia', 'Ministro Carranza',
    'Olleros', 'Jose Hernandez', 'Juramento', 'Congreso de Tucuman'
]
LISTA_ESTACIONES_SUR = LISTA_ESTACIONES_NORTE[::-1]
TIEMPO_SIMULACION_SEG = 3600 # 1 Hora
INTERVALO_LAMBDA_SEG = 900 # 15 min
MAPAS_DESCENSO_BASE = {
    "Hacia Catedral": {
        'Congreso de Tucuman': 0.0, 'Juramento': 0.05, 'Jose Hernandez': 0.05, 'Olleros': 0.05,
        'Ministro Carranza': 0.20, 'Plaza Italia': 0.05, 'Bulnes': 0.05,
        'Pueyrredon.D': 0.25, 'Ag√ºero': 0.10, 'Facultad de Medicina': 0.15, 'Callao': 0.20,
        'Tribunales': 0.30, '9 de Julio': 0.40, 'Catedral': 1.0
    },
    "Hacia Congreso": {
        'Catedral': 0.0, '9 de Julio': 0.30, 'Tribunales': 0.25, 'Callao': 0.25,
        'Facultad de Medicina': 0.20, 'Ag√ºero': 0.20, 'Pueyrredon.D': 0.35,
        'Bulnes': 0.25, 'Plaza Italia': 0.35, 'Ministro Carranza': 0.35,
        'Olleros': 0.25, 'Jose Hernandez': 0.25, 'Juramento': 0.30,
        'Congreso de Tucuman': 1.0
    }
}
class Anden:
    def __init__(self, env, nombre_estacion, direccion):
        self.env = env
        self.nombre = f"{nombre_estacion}_{direccion}"
        self.direccion = direccion
        self.estacion_nombre = nombre_estacion
        self.cola_pasajeros = simpy.Store(env)
        self.metricas_tiempo_espera = []
        self.metricas_cola_por_tren = []
    def add_pasajero(self, pasajero):
        pasajero['tiempo_llegada_anden'] = self.env.now
        return self.cola_pasajeros.put(pasajero)
    def tren_llega_a_anden(self, tren, dwell_time):
        pasajeros_en_cola_al_llegar = len(self.cola_pasajeros.items)
        self.metricas_cola_por_tren.append(pasajeros_en_cola_al_llegar)
        pasajeros_subidos = 0
        while tren['pasajeros_actuales'] < tren['capacidad'] and len(self.cola_pasajeros.items) > 0:
            pasajero = yield self.cola_pasajeros.get()
            tiempo_espera = self.env.now - pasajero['tiempo_llegada_anden']
            self.metricas_tiempo_espera.append(tiempo_espera)
            tren['pasajeros_actuales'] += 1
            pasajeros_subidos += 1
        yield self.env.timeout(dwell_time)
def generador_pasajeros(env, anden, df_lambda, intervalo_seg):
    lambda_data = df_lambda[
        (df_lambda['ESTACION'] == anden.estacion_nombre) &
        (df_lambda['DIRECCION'] == anden.direccion)
    ].set_index('DESDE')
    intervalos = ['08:00:00', '08:15:00', '08:30:00', '08:45:00']
    for intervalo_hora in intervalos:
        lambda_actual = 0.0
        try: lambda_actual = lambda_data.loc[intervalo_hora]['pasajeros_PROMEDIO_lambda']
        except KeyError: pass
        if lambda_actual > 0:
            seg_entre_pasajeros = intervalo_seg / lambda_actual
            inicio_intervalo = env.now
            while env.now < inicio_intervalo + intervalo_seg:
                tiempo_llegada_prox_pax = random.expovariate(1.0 / seg_entre_pasajeros)
                yield env.timeout(tiempo_llegada_prox_pax)
                if env.now < inicio_intervalo + intervalo_seg:
                    pasajero = {'id': f"pax_{random.randint(1000,9999)}"}
                    yield anden.add_pasajero(pasajero)
        else:
            yield env.timeout(intervalo_seg)
def proceso_tren(env, tren_id, lista_recorrido, tiempo_viaje, dwell_time, capacidad, mundo_andenes, tasas_descenso):
    tren = {'id': tren_id, 'capacidad': capacidad, 'pasajeros_actuales': 0}
    direccion_viaje = "Hacia Congreso" if lista_recorrido == LISTA_ESTACIONES_NORTE else "Hacia Catedral"
    for i, nombre_estacion in enumerate(lista_recorrido):
        if i > 0:
            yield env.timeout(tiempo_viaje)
        nombre_anden = f"{nombre_estacion}_{direccion_viaje}"
        anden_actual = mundo_andenes[nombre_anden]
        if tren['pasajeros_actuales'] > 0:
            tasa_bajada = tasas_descenso[nombre_estacion]
            pasajeros_que_bajan = np.random.binomial(tren['pasajeros_actuales'], tasa_bajada)
            tren['pasajeros_actuales'] -= pasajeros_que_bajan
        yield env.process(anden_actual.tren_llega_a_anden(tren, dwell_time))
def generador_trenes(env, direccion, lista_recorrido, min_freq, max_freq, tiempo_viaje, dwell_time, capacidad, mundo_andenes, tasas_descenso):
    tren_id_counter = 0
    while True:
        frecuencia = random.uniform(min_freq, max_freq)
        yield env.timeout(frecuencia)
        tren_id_counter += 1
        tren_id = f"Tren_{direccion}_{tren_id_counter}"
        env.process(proceso_tren(env, tren_id, lista_recorrido, tiempo_viaje, dwell_time, capacidad, mundo_andenes, tasas_descenso))

# --- 3. FUNCI√ìN PRINCIPAL DE SIMULACI√ìN (MONTECARLO) ---

# --- (NUEVO) Funci√≥n para calcular Intervalos de Confianza ---
def confidence_interval(data):
    """
    Calcula el intervalo de confianza del 95% para la media de una muestra.
    Usa la distribuci√≥n T de Student, que es robusta para N<30 (aunque N=50 est√° bien).
    """
    if len(data) < 2:
        return (0, 0) # No se puede calcular con 1 solo dato

    confidence = 0.95
    n = len(data)
    mean = np.mean(data)
    sem = stats.sem(data) # Error Est√°ndar de la Media

    # Calcular el intervalo
    ci = stats.t.interval(confidence, n - 1, loc=mean, scale=sem)
    return ci

# --- (MODIFICACI√ìN: Funci√≥n Montecarlo ahora calcula CIs) ---
def run_montecarlo_simulation(
    n_replicaciones, min_freq, max_freq, capacidad, dwell_time, tiempo_viaje,
    df_lambda, mapas_descenso_base,
    multiplicador_catedral, multiplicador_congreso
    ):

    print(f"Iniciando Montecarlo con {n_replicaciones} r√©plicas...")
    lista_de_resultados_global = []

    mapas_descenso_ajustados = {
        "Hacia Catedral": {
            estacion: min(tasa * multiplicador_catedral, 1.0)
            for estacion, tasa in mapas_descenso_base["Hacia Catedral"].items()
        },
        "Hacia Congreso": {
            estacion: min(tasa * multiplicador_congreso, 1.0)
            for estacion, tasa in mapas_descenso_base["Hacia Congreso"].items()
        }
    }

    progress_bar = st.progress(0, text="Iniciando simulaci√≥n...")

    # Bucle de Replicaci√≥n (Id√©ntico)
    for i in range(n_replicaciones):
        semilla_actual = i + 1
        progress_bar.progress((i + 1) / n_replicaciones, text=f"Corriendo R√©plica {semilla_actual}/{n_replicaciones}...")

        random.seed(semilla_actual)
        np.random.seed(semilla_actual)

        env = simpy.Environment()
        mundo_andenes = {}
        for estacion in LISTA_ESTACIONES_NORTE:
            anden_norte = Anden(env, estacion, "Hacia Congreso")
            mundo_andenes[anden_norte.nombre] = anden_norte
            anden_sur = Anden(env, estacion, "Hacia Catedral")
            mundo_andenes[anden_sur.nombre] = anden_sur

        for anden_obj in mundo_andenes.values():
            env.process(generador_pasajeros(env, anden_obj, df_lambda, INTERVALO_LAMBDA_SEG))
        env.process(generador_trenes(
            env, "Hacia_Congreso", LISTA_ESTACIONES_NORTE, min_freq, max_freq,
            tiempo_viaje, dwell_time, capacidad, mundo_andenes,
            mapas_descenso_ajustados["Hacia Congreso"]
        ))
        env.process(generador_trenes(
            env, "Hacia_Catedral", LISTA_ESTACIONES_SUR, min_freq, max_freq,
            tiempo_viaje, dwell_time, capacidad, mundo_andenes,
            mapas_descenso_ajustados["Hacia Catedral"]
        ))

        env.run(until=TIEMPO_SIMULACION_SEG)

        for anden_obj in mundo_andenes.values():
            t_espera = anden_obj.metricas_tiempo_espera
            l_cola = anden_obj.metricas_cola_por_tren

            lista_de_resultados_global.append({
                'Anden': anden_obj.nombre,
                'Replica': semilla_actual,
                'Tiempo_Espera_Promedio_Seg': np.mean(t_espera) if len(t_espera) > 0 else 0,
                'Cola_Maxima_VISTA': np.max(l_cola) if len(l_cola) > 0 else 0
            })

    print("Montecarlo terminado. Analizando resultados...")
    progress_bar.empty()

    # --- An√°lisis Estad√≠stico Final (MODIFICADO) ---
    df_global_stats = pd.DataFrame(lista_de_resultados_global)

    # --- (NUEVO) Calcular CIs usando .agg() ---

    # Funci√≥n lambda para extraer el l√≠mite inferior del CI
    ci_lower = lambda x: confidence_interval(x)[0]
    # Funci√≥n lambda para extraer el l√≠mite superior del CI
    ci_upper = lambda x: confidence_interval(x)[1]

    df_resumen_estadistico = df_global_stats.groupby('Anden').agg(
        # Agregamos las funciones de CI a la agregaci√≥n
        Cola_Max_Promedio=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='mean'),
        Cola_Max_CI_95_Bajo=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc=ci_lower),
        Cola_Max_CI_95_Alto=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc=ci_upper),
        Cola_Max_Min_Observado=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='min'),
        Cola_Max_Max_Observado=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='max'),

        Espera_Prom_Promedio_Seg=pd.NamedAgg(column='Tiempo_Espera_Promedio_Seg', aggfunc='mean'),
        Espera_Prom_CI_95_Bajo=pd.NamedAgg(column='Tiempo_Espera_Promedio_Seg', aggfunc=ci_lower),
        Espera_Prom_CI_95_Alto=pd.NamedAgg(column='Tiempo_Espera_Promedio_Seg', aggfunc=ci_upper),
        Espera_Prom_Max_Observado_Seg=pd.NamedAgg(column='Tiempo_Espera_Promedio_Seg', aggfunc='max')

    ).sort_values(by='Cola_Max_Promedio', ascending=False)

    # Redondear para mejor visualizaci√≥n
    df_resumen_estadistico = df_resumen_estadistico.round(2)

    return df_resumen_estadistico, df_global_stats


# --- 4. INTERFAZ DE USUARIO (STREAMLIT) ---

st.title("üöá Simulador de la L√≠nea D (Modelo TPI)")
st.write("Esta app ejecuta un modelo de Simulaci√≥n de Eventos Discretos (SimPy) para la L√≠nea D, basado en el TPI.")

# --- Barra Lateral (Id√©ntica a v2) ---
st.sidebar.header("Par√°metros de Simulaci√≥n üõ†Ô∏è")
with st.sidebar.expander("1. Configuraci√≥n General", expanded=True):
    n_replicaciones = st.sidebar.slider(
        "N¬∞ de Corridas (Montecarlo)", min_value=1, max_value=100, value=50, step=1,
        help="N√∫mero de veces que se corre la simulaci√≥n (con diferentes semillas) para obtener un resultado estad√≠stico."
    )
with st.sidebar.expander("2. Par√°metros de Oferta (Tren)", expanded=True):
    capacidad = st.sidebar.slider(
        "Capacidad del Tren (Pasajeros)", min_value=1000, max_value=2000, value=1500, step=50,
        help="Capacidad m√°xima ('de estr√©s') de un convoy."
    )
    dwell_time = st.sidebar.slider(
        "Tiempo de Detenci√≥n (Segundos)", min_value=15, max_value=60, value=30, step=1,
        help="Tiempo (en segundos) que el tren permanece detenido en cada estaci√≥n (Dwell Time)."
    )
    tiempo_viaje = st.sidebar.slider(
        "Tiempo de Viaje (Segundos)", min_value=60, max_value=180, value=120, step=5,
        help="Tiempo (en segundos) que tarda el tren en viajar entre una estaci√≥n y la siguiente."
    )
with st.sidebar.expander("3. Par√°metros de Frecuencia (Tren)", expanded=False):
    min_freq = st.sidebar.slider(
        "Frecuencia M√≠nima (Segundos)", min_value=60, max_value=300, value=120, step=10
    )
    max_freq = st.sidebar.slider(
        "Frecuencia M√°xima (Segundos)", min_value=120, max_value=360, value=180, step=10
    )
with st.sidebar.expander("4. Par√°metros de Demanda (Descenso)", expanded=True):
    st.info("Ajusta las tasas de descenso base (V2/V4). 1.0 = 100% (sin cambios), 1.2 = 120% (20% m√°s).")
    multiplicador_catedral = st.sidebar.slider(
        "Multiplicador Descenso (H. Catedral)",
        min_value=0.5, max_value=2.0, value=1.0, step=0.05
    )
    multiplicador_congreso = st.sidebar.slider(
        "Multiplicador Descenso (H. Congreso)",
        min_value=0.5, max_value=2.0, value=1.0, step=0.05
    )

# --- L√≥gica Principal de la App ---
st.header("1. Cargar Datos y Ejecutar Simulaci√≥n")
st.write("El modelo est√° configurado para descargar los datos de demanda (Enero) desde GitHub.")

# Cargar y procesar datos autom√°ticamente
df_lambda_final = load_and_clean_data(DATA_URL)

if df_lambda_final is not None:
    st.success("Datos de Lambda (Œª) cargados y procesados exitosamente.")
    with st.expander("Ver tabla de Demanda (Lambda)"):
        st.dataframe(df_lambda_final)

    # Bot√≥n para correr la simulaci√≥n
    if st.button("‚ñ∂Ô∏è Correr Simulaci√≥n (Escenario Montecarlo)"):

        with st.spinner(f"Ejecutando {n_replicaciones} corridas..."):
            df_resumen, df_global = run_montecarlo_simulation(
                n_replicaciones, min_freq, max_freq, capacidad,
                dwell_time, tiempo_viaje, df_lambda_final, MAPAS_DESCENSO_BASE,
                multiplicador_catedral, multiplicador_congreso
            )

        st.success("¬°Simulaci√≥n completada!")

        # --- (MODIFICACI√ìN: Pesta√±as de Resultados Mejoradas) ---
        st.header("2. Resultados del Experimento")

        # Guardar resultados en el estado de la sesi√≥n para usarlos en otras pesta√±as
        st.session_state['df_resumen'] = df_resumen
        st.session_state['df_global'] = df_global
        st.session_state['n_replicaciones'] = n_replicaciones

    # --- Mostrar resultados (siempre que existan en el estado) ---
    if 'df_resumen' in st.session_state:
        # Extraer datos del estado
        df_resumen = st.session_state['df_resumen']
        df_global = st.session_state['df_global']
        n_replicaciones = st.session_state['n_replicaciones']

        # --- (NUEVO) Pesta√±a 4: Distribuci√≥n (Histograma) ---
        tab1, tab2, tab3, tab4 = st.tabs([
            "üìä Resumen Estad√≠stico (CI 95%)",
            "üìà Gr√°ficos de Cuellos de Botella",
            "üåç Distribuci√≥n (Histograma)",
            "üìã Datos Crudos (Global)"
        ])

        with tab1:
            st.subheader("Resumen Estad√≠stico (Agregado de Corridas)")
            st.write(f"Resultados basados en {n_replicaciones} corridas, mostrando la media e Intervalos de Confianza del 95%.")
            st.dataframe(df_resumen)
            with st.expander("Detalle de las columnas"):
                st.markdown("""
                - **Cola_Max_Promedio**: La media de las colas m√°ximas observadas en las {n_replicaciones} corridas.
                - **Cola_Max_CI_95_Bajo / Alto**: **Intervalo de Confianza del 95%**. Tenemos 95% de confianza de que la *verdadera* media de la cola m√°xima del sistema est√° entre estos two valores.
                - **Cola_Max_Min_Observado**: La cola m√°xima m√°s *baja* que se vio en la "mejor" corrida.
                - **Cola_Max_Max_Observado**: La cola m√°xima m√°s *alta* que se vio en la "peor" corrida.
                - **Espera_Prom_...**: Mismas m√©tricas, pero para el tiempo de espera promedio.
                """.format(n_replicaciones=n_replicaciones))

        with tab2:
            st.subheader("Visualizaci√≥n de Cuellos de Botella")
            st.write("**Gr√°fico 1: Cola M√°xima Promedio (y su Intervalo de Confianza 95%)**")

            # Gr√°fico 1: Colas (Mejorado con CI)
            df_sorted_colas = df_resumen.sort_values(by='Cola_Max_Promedio', ascending=False)
            df_chart_colas = pd.DataFrame({
                "Promedio": df_sorted_colas['Cola_Max_Promedio'],
                "CI 95% Bajo": df_sorted_colas['Cola_Max_CI_95_Bajo'],
                "CI 95% Alto": df_sorted_colas['Cola_Max_CI_95_Alto']
            })
            st.bar_chart(df_chart_colas)

            # Gr√°fico 2: Esperas
            st.write("**Gr√°fico 2: Tiempo de Espera Promedio (y su Intervalo de Confianza 95%)**")
            df_sorted_espera = df_resumen.sort_values(by='Espera_Prom_Promedio_Seg', ascending=False)
            df_chart_espera = pd.DataFrame({
                "Promedio": df_sorted_espera['Espera_Prom_Promedio_Seg'],
                "CI 95% Bajo": df_sorted_espera['Espera_Prom_CI_95_Bajo'],
                "CI 95% Alto": df_sorted_espera['Espera_Prom_CI_95_Alto']
            })
            st.bar_chart(df_chart_espera)

        with tab3:
            st.subheader("An√°lisis Espec√≠fico: Distribuci√≥n de Resultados")
            st.write(f"Analiz√° la variabilidad de las {n_replicaciones} corridas para un and√©n espec√≠fico.")

            # Selector para el and√©n
            anden_seleccionado = st.selectbox(
                "Seleccion√° un And√©n para analizar:",
                df_resumen.index.sort_values()
            )

            if anden_seleccionado:
                # Filtrar el df_global para ese and√©n
                data_anden = df_global[df_global['Anden'] == anden_seleccionado]

                col1, col2 = st.columns(2)

                with col1:
                    st.write("**Distribuci√≥n de 'Cola M√°xima' (Histograma)**")
                    # Crear figura de Matplotlib (para m√°s control)
                    fig_cola, ax_cola = plt.subplots()
                    ax_cola.hist(data_anden['Cola_Maxima_VISTA'], bins=15, alpha=0.7, edgecolor='black')
                    ax_cola.set_title(f"Distribuci√≥n 'Cola M√°xima' en {anden_seleccionado}")
                    ax_cola.set_xlabel("Cola M√°xima (Pasajeros)")
                    ax_cola.set_ylabel("Frecuencia (de 50 corridas)")
                    st.pyplot(fig_cola)

                with col2:
                    st.write("**Distribuci√≥n de 'Espera Promedio' (Histograma)**")
                    fig_espera, ax_espera = plt.subplots()
                    ax_espera.hist(data_anden['Tiempo_Espera_Promedio_Seg'], bins=15, alpha=0.7, color='blue', edgecolor='black')
                    ax_espera.set_title(f"Distribuci√≥n 'Espera Promedio' en {anden_seleccionado}")
                    ax_espera.set_xlabel("Espera Promedio (Segundos)")
                    ax_espera.set_ylabel("Frecuencia (de 50 corridas)")
                    st.pyplot(fig_espera)

        with tab4:
            st.subheader("Datos Crudos de las R√©plicas")
            st.write(f"Resultados detallados de todas las {n_replicaciones} corridas (Total {len(df_global)} filas).")
            st.dataframe(df_global)

        st.info("Simulaci√≥n finalizada. Pod√©s cambiar los par√°metros de la barra lateral y volver a correr.")
else:
    st.error("No se pudieron cargar los datos de Lambda. Revisa el link en DATA_URL.")