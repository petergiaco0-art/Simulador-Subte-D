# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SoLmuZTExarBoGcLiz5zTI7SlJNr7Xk-
"""

import streamlit as st
import pandas as pd
import numpy as np
import simpy
import random
import csv
import matplotlib.pyplot as plt

# --- 0. CONFIGURACI√ìN DE LA P√ÅGINA ---
# (Esto debe ser lo primero que llama Streamlit)
st.set_page_config(
    page_title="Simulador Subte L√≠nea D",
    layout="wide"
)

# --- 1. FUNCIONES DE CARGA Y LIMPIEZA DE DATOS ---
# (Usamos @st.cache_data para que no se re-ejecute cada vez)

@st.cache_data
def load_and_clean_data(uploaded_file):
    """
    Toma el archivo CSV subido, lo carga con los par√°metros especiales
    y realiza la limpieza de datos (comillas, tipos, nulos, etc.)
    """
    print("Iniciando carga y limpieza de datos...")

    # --- Carga de Datos ---
    # Usamos 'utf-8-sig' para el BOM (√Ø¬ª¬ø) y QUOTE_NONE para comillas
    try:
        df = pd.read_csv(
            uploaded_file,
            sep=';',
            encoding='utf-8-sig',
            quoting=csv.QUOTE_NONE,
            low_memory=False
        )
    except Exception as e:
        st.error(f"Error fatal al leer el CSV: {e}")
        return None

    # --- Limpieza de Encabezados y Datos ---
    df.columns = df.columns.str.replace('"', '', regex=False).str.strip()

    # Validar columnas clave
    required_cols = ['FECHA', 'pax_TOTAL', 'ESTACION', 'LINEA', 'MOLINETE', 'DESDE']
    if not all(col in df.columns for col in required_cols):
        st.error(f"Error: El CSV no contiene todas las columnas requeridas: {required_cols}")
        return None

    df['FECHA'] = df['FECHA'].astype(str).str.replace('"', '', regex=False).str.strip()
    df['pax_TOTAL'] = df['pax_TOTAL'].astype(str).str.replace('"', '', regex=False).str.strip()
    df['LINEA'] = df['LINEA'].astype(str).str.strip()
    df['ESTACION'] = df['ESTACION'].astype(str).str.strip()

    # --- Filtrado (L√≠nea D) ---
    df_linea_d = df[df['LINEA'] == 'LineaD'].copy()

    # --- Unificaci√≥n de Estaciones (Calidad de Datos) ---
    df_linea_d['ESTACION'] = df_linea_d['ESTACION'].replace('9 de julio', '9 de Julio')
    df_linea_d['ESTACION'] = df_linea_d['ESTACION'].replace('Ag√É¬ºero', 'Ag√ºero')

    # --- Conversi√≥n de Tipos y Manejo de Nulos ---
    df_linea_d['FECHA'] = pd.to_datetime(df_linea_d['FECHA'], format='%d/%m/%Y')
    df_linea_d['pax_TOTAL'] = pd.to_numeric(df_linea_d['pax_TOTAL'], errors='coerce')
    df_linea_d.dropna(subset=['pax_TOTAL'], inplace=True)
    df_linea_d['pax_TOTAL'] = df_linea_d['pax_TOTAL'].astype(int)

    print("Carga y limpieza de datos completada.")
    return df_linea_d


# --- Funci√≥n de Inferencia de Demanda ---
def asignar_direccion(row):
    """
    Asigna direcci√≥n ('Hacia Catedral', 'Hacia Congreso' o 'Ponderar')
    basado en la l√≥gica V2 (la que corregimos para 9 de Julio).
    """
    estacion = row['ESTACION']
    molinete = str(row['MOLINETE'])

    if estacion == 'Catedral': return 'Hacia Congreso'
    if estacion == 'Congreso de Tucuman': return 'Hacia Catedral'
    if estacion == '9 de Julio': return 'Ponderar' # Caso especial
    if '_N_' in molinete: return 'Hacia Congreso'
    if '_S_' in molinete or '_SO_' in molinete: return 'Hacia Catedral'
    if '_Este_' in molinete or '_E_' in molinete: return 'Hacia Catedral'
    if '_Oeste_' in molinete or '_O_' in molinete: return 'Hacia Congreso'
    return 'Ponderar' # Resto (Ag√ºero, etc.)

@st.cache_data
def calculate_lambda(df_linea_d):
    """
    Aplica la l√≥gica de inferencia de direcci√≥n y calcula
    el DataFrame de Lambda (Œª) final.
    """
    print("Iniciando c√°lculo de Lambda...")

    # 1. Aplicar reglas de direcci√≥n
    df_linea_d['DIRECCION'] = df_linea_d.apply(asignar_direccion, axis=1)

    # 2. Ponderar (Duplicar filas 50/50)
    df_con_direccion = df_linea_d[df_linea_d['DIRECCION'] != 'Ponderar'].copy()
    df_para_ponderar = df_linea_d[df_linea_d['DIRECCION'] == 'Ponderar'].copy()

    df_ponderar_catedral = df_para_ponderar.copy()
    df_ponderar_congreso = df_para_ponderar.copy()

    df_ponderar_catedral['DIRECCION'] = 'Hacia Catedral'
    df_ponderar_catedral['pax_TOTAL'] = df_ponderar_catedral['pax_TOTAL'] * 0.5
    df_ponderar_congreso['DIRECCION'] = 'Hacia Congreso'
    df_ponderar_congreso['pax_TOTAL'] = df_ponderar_congreso['pax_TOTAL'] * 0.5

    df_direccional = pd.concat([df_con_direccion, df_ponderar_catedral, df_ponderar_congreso], ignore_index=True)

    # 3. Filtrar por Hora Pico (08:00 a 09:00)
    df_direccional['pax_TOTAL'] = pd.to_numeric(df_direccional['pax_TOTAL'], errors='coerce')
    df_direccional.dropna(subset=['pax_TOTAL'], inplace=True)

    condicion_pico_1hr = (df_direccional['DESDE'] >= '08:00:00') & (df_direccional['DESDE'] < '09:00:00')
    df_pico_direccional = df_direccional[condicion_pico_1hr].copy()

    # 4. Calcular Lambda (Promedio)
    df_lambda_final = df_pico_direccional.groupby(
        ['ESTACION', 'DIRECCION', 'DESDE']
    )['pax_TOTAL'].mean().reset_index()

    df_lambda_final = df_lambda_final.rename(columns={'pax_TOTAL': 'pasajeros_PROMEDIO_lambda'})

    print("C√°lculo de Lambda completado.")
    return df_lambda_final


# --- 2. COMPONENTES DEL MODELO SIMPY ---
# (Todo el c√≥digo de la simulaci√≥n: Clase Anden y Procesos)

# --- MAPA Y CONFIGURACI√ìN (CONSTANTES) ---
LISTA_ESTACIONES_NORTE = [
    'Catedral', '9 de Julio', 'Tribunales', 'Callao', 'Facultad de Medicina',
    'Ag√ºero', 'Pueyrredon.D', 'Bulnes', 'Plaza Italia', 'Ministro Carranza',
    'Olleros', 'Jose Hernandez', 'Juramento', 'Congreso de Tucuman'
]
LISTA_ESTACIONES_SUR = LISTA_ESTACIONES_NORTE[::-1]
TIEMPO_SIMULACION_SEG = 3600 # 1 Hora
INTERVALO_LAMBDA_SEG = 900 # 15 min

# --- Mapas de Descenso (del Escenario 5 / V4) ---
TASAS_DESCENSO_HACIA_CATEDRAL_V2 = {
    'Congreso de Tucuman': 0.0, 'Juramento': 0.05, 'Jose Hernandez': 0.05, 'Olleros': 0.05,
    'Ministro Carranza': 0.20, 'Plaza Italia': 0.05, 'Bulnes': 0.05,
    'Pueyrredon.D': 0.25, 'Ag√ºero': 0.10, 'Facultad de Medicina': 0.15, 'Callao': 0.20,
    'Tribunales': 0.30, '9 de Julio': 0.40, 'Catedral': 1.0
}
TASAS_DESCENSO_HACIA_CONGRESO_V4 = {
    'Catedral': 0.0, '9 de Julio': 0.30, 'Tribunales': 0.25, 'Callao': 0.25,
    'Facultad de Medicina': 0.20, 'Ag√ºero': 0.20, 'Pueyrredon.D': 0.35,
    'Bulnes': 0.25, 'Plaza Italia': 0.35, 'Ministro Carranza': 0.35,
    'Olleros': 0.25, 'Jose Hernandez': 0.25, 'Juramento': 0.30,
    'Congreso de Tucuman': 1.0
}
MAPAS_DESCENSO = {
    "Hacia Catedral": TASAS_DESCENSO_HACIA_CATEDRAL_V2,
    "Hacia Congreso": TASAS_DESCENSO_HACIA_CONGRESO_V4
}

# --- Clase Anden ---
class Anden:
    def __init__(self, env, nombre_estacion, direccion):
        self.env = env
        self.nombre = f"{nombre_estacion}_{direccion}"
        self.direccion = direccion
        self.estacion_nombre = nombre_estacion
        self.cola_pasajeros = simpy.Store(env)
        self.metricas_tiempo_espera = []
        self.metricas_cola_por_tren = []

    def add_pasajero(self, pasajero):
        pasajero['tiempo_llegada_anden'] = self.env.now
        return self.cola_pasajeros.put(pasajero)

    def tren_llega_a_anden(self, tren, dwell_time):
        pasajeros_en_cola_al_llegar = len(self.cola_pasajeros.items)
        self.metricas_cola_por_tren.append(pasajeros_en_cola_al_llegar)
        pasajeros_subidos = 0

        while tren['pasajeros_actuales'] < tren['capacidad'] and len(self.cola_pasajeros.items) > 0:
            pasajero = yield self.cola_pasajeros.get()
            tiempo_espera = self.env.now - pasajero['tiempo_llegada_anden']
            self.metricas_tiempo_espera.append(tiempo_espera)
            tren['pasajeros_actuales'] += 1
            pasajeros_subidos += 1

        yield self.env.timeout(dwell_time)

# --- Procesos SimPy ---
def generador_pasajeros(env, anden, df_lambda, intervalo_seg):
    lambda_data = df_lambda[
        (df_lambda['ESTACION'] == anden.estacion_nombre) &
        (df_lambda['DIRECCION'] == anden.direccion)
    ].set_index('DESDE')
    intervalos = ['08:00:00', '08:15:00', '08:30:00', '08:45:00']

    for intervalo_hora in intervalos:
        lambda_actual = 0.0
        try: lambda_actual = lambda_data.loc[intervalo_hora]['pasajeros_PROMEDIO_lambda']
        except KeyError: pass
        if lambda_actual > 0:
            seg_entre_pasajeros = intervalo_seg / lambda_actual
            inicio_intervalo = env.now
            while env.now < inicio_intervalo + intervalo_seg:
                tiempo_llegada_prox_pax = random.expovariate(1.0 / seg_entre_pasajeros)
                yield env.timeout(tiempo_llegada_prox_pax)
                if env.now < inicio_intervalo + intervalo_seg:
                    pasajero = {'id': f"pax_{random.randint(1000,9999)}"}
                    yield anden.add_pasajero(pasajero)
        else:
            yield env.timeout(intervalo_seg)

def proceso_tren(env, tren_id, lista_recorrido, tiempo_viaje, dwell_time, capacidad, mundo_andenes, tasas_descenso):
    tren = {
        'id': tren_id,
        'capacidad': capacidad,
        'pasajeros_actuales': 0
    }
    direccion_viaje = "Hacia Congreso" if lista_recorrido == LISTA_ESTACIONES_NORTE else "Hacia Catedral"

    for i, nombre_estacion in enumerate(lista_recorrido):
        if i > 0:
            yield env.timeout(tiempo_viaje)

        nombre_anden = f"{nombre_estacion}_{direccion_viaje}"
        anden_actual = mundo_andenes[nombre_anden]

        if tren['pasajeros_actuales'] > 0:
            tasa_bajada = tasas_descenso[nombre_estacion]
            pasajeros_que_bajan = np.random.binomial(tren['pasajeros_actuales'], tasa_bajada)
            tren['pasajeros_actuales'] -= pasajeros_que_bajan

        yield env.process(anden_actual.tren_llega_a_anden(tren, dwell_time))

def generador_trenes(env, direccion, lista_recorrido, min_freq, max_freq, tiempo_viaje, dwell_time, capacidad, mundo_andenes, tasas_descenso):
    tren_id_counter = 0
    while True:
        frecuencia = random.uniform(min_freq, max_freq)
        yield env.timeout(frecuencia)

        tren_id_counter += 1
        tren_id = f"Tren_{direccion}_{tren_id_counter}"

        env.process(proceso_tren(
            env, tren_id, lista_recorrido, tiempo_viaje, dwell_time,
            capacidad, mundo_andenes, tasas_descenso
        ))

# --- 3. FUNCI√ìN PRINCIPAL DE SIMULACI√ìN (MONTECARLO) ---

def run_montecarlo_simulation(n_replicaciones, min_freq, max_freq, capacidad, dwell_time, tiempo_viaje, df_lambda, mapas_descenso):
    """
    Ejecuta el bucle de Montecarlo (N r√©plicas)
    con los par√°metros recibidos de la interfaz.
    """
    print(f"Iniciando Montecarlo con {n_replicaciones} r√©plicas...")
    lista_de_resultados_global = []

    # Bucle de Replicaci√≥n
    for i in range(n_replicaciones):
        semilla_actual = i + 1
        print(f"Corriendo R√©plica {semilla_actual}/{n_replicaciones}...")

        random.seed(semilla_actual)
        np.random.seed(semilla_actual)

        env = simpy.Environment()
        mundo_andenes = {}
        for estacion in LISTA_ESTACIONES_NORTE:
            anden_norte = Anden(env, estacion, "Hacia Congreso")
            mundo_andenes[anden_norte.nombre] = anden_norte
            anden_sur = Anden(env, estacion, "Hacia Catedral")
            mundo_andenes[anden_sur.nombre] = anden_sur

        for anden_obj in mundo_andenes.values():
            env.process(generador_pasajeros(env, anden_obj, df_lambda, INTERVALO_LAMBDA_SEG))

        # Generador Hacia Congreso
        env.process(generador_trenes(
            env, "Hacia_Congreso", LISTA_ESTACIONES_NORTE, min_freq, max_freq,
            tiempo_viaje, dwell_time, capacidad, mundo_andenes,
            mapas_descenso["Hacia Congreso"]
        ))
        # Generador Hacia Catedral
        env.process(generador_trenes(
            env, "Hacia_Catedral", LISTA_ESTACIONES_SUR, min_freq, max_freq,
            tiempo_viaje, dwell_time, capacidad, mundo_andenes,
            mapas_descenso["Hacia Catedral"]
        ))

        env.run(until=TIEMPO_SIMULACION_SEG)

        # Recopilar resultados de esta r√©plica
        for anden_obj in mundo_andenes.values():
            t_espera = anden_obj.metricas_tiempo_espera
            l_cola = anden_obj.metricas_cola_por_tren

            lista_de_resultados_global.append({
                'Anden': anden_obj.nombre,
                'Replica': semilla_actual,
                'Tiempo_Espera_Promedio_Seg': np.mean(t_espera) if len(t_espera) > 0 else 0,
                'Cola_Maxima_VISTA': np.max(l_cola) if len(l_cola) > 0 else 0
            })

    print("Montecarlo terminado. Analizando resultados...")

    # --- An√°lisis Estad√≠stico Final ---
    df_global_stats = pd.DataFrame(lista_de_resultados_global)
    df_resumen_estadistico = df_global_stats.groupby('Anden').agg(
        Cola_Max_Promedio=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='mean'),
        Cola_Max_Min=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='min'),
        Cola_Max_Max=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='max'),
        Espera_Prom_Promedio_Seg=pd.NamedAgg(column='Tiempo_Espera_Promedio_Seg', aggfunc='mean'),
        Espera_Prom_Max_Seg=pd.NamedAgg(column='Tiempo_Espera_Promedio_Seg', aggfunc='max')
    ).sort_values(by='Cola_Max_Promedio', ascending=False)

    return df_resumen_estadistico, df_global_stats


# --- 4. INTERFAZ DE USUARIO (STREAMLIT) ---

st.title("üöá Simulador de la L√≠nea D (Modelo TPI)")
st.write("Esta app ejecuta un modelo de Simulaci√≥n de Eventos Discretos (SimPy) para la L√≠nea D, basado en el TPI.")

# --- Barra Lateral (Sidebar) para Par√°metros ---
st.sidebar.header("Par√°metros de Simulaci√≥n üõ†Ô∏è")

# Par√°metros de Simulaci√≥n
st.sidebar.subheader("Configuraci√≥n General")
n_replicaciones = st.sidebar.slider(
    "N¬∞ de Corridas (Montecarlo)",
    min_value=1, max_value=100, value=50, step=1,
    help="N√∫mero de veces que se corre la simulaci√≥n (con diferentes semillas) para obtener un resultado estad√≠stico."
)

# Par√°metros de Oferta (Trenes)
st.sidebar.subheader("Par√°metros de Oferta (Tren)")
capacidad = st.sidebar.slider(
    "Capacidad del Tren (Pasajeros)",
    min_value=1000, max_value=2000, value=1500, step=50,
    help="Capacidad m√°xima ('de estr√©s') de un convoy."
)
min_freq = st.sidebar.slider(
    "Frecuencia M√≠nima (Segundos)",
    min_value=60, max_value=300, value=120, step=10,
    help="Tiempo m√≠nimo (en segundos) que tarda en salir un tren de la terminal (ej. 120s = 2 min)."
)
max_freq = st.sidebar.slider(
    "Frecuencia M√°xima (Segundos)",
    min_value=120, max_value=360, value=180, step=10,
    help="Tiempo m√°ximo (en segundos) que tarda en salir un tren (ej. 180s = 3 min)."
)
dwell_time = st.sidebar.slider(
    "Tiempo de Detenci√≥n (Segundos)",
    min_value=15, max_value=60, value=30, step=1,
    help="Tiempo (en segundos) que el tren permanece detenido en cada estaci√≥n (Dwell Time)."
)
tiempo_viaje = st.sidebar.slider(
    "Tiempo de Viaje (Segundos)",
    min_value=60, max_value=180, value=120, step=5,
    help="Tiempo (en segundos) que tarda el tren en viajar entre una estaci√≥n y la siguiente."
)


# --- Carga de Datos de Demanda ---
st.header("1. Cargar Datos de Demanda")
uploaded_file = st.file_uploader(
    "Carg√° tu archivo CSV de demanda (202501_D.csv)",
    type="csv"
)

# --- Ejecuci√≥n de la Simulaci√≥n ---
if uploaded_file is not None:
    # 1. Cargar y procesar datos
    df_linea_d = load_and_clean_data(uploaded_file)
    df_lambda_final = calculate_lambda(df_linea_d)

    st.success("Archivo CSV cargado y procesado exitosamente.")
    st.write("Vista previa de la demanda (Tasa Lambda Œª):")
    st.dataframe(df_lambda_final.head())

    # 2. Bot√≥n para correr la simulaci√≥n
    st.header("2. Ejecutar Simulaci√≥n")
    if st.button("‚ñ∂Ô∏è Correr Simulaci√≥n (Escenario Montecarlo)"):

        with st.spinner(f"Ejecutando {n_replicaciones} corridas... Esto puede tardar uno o dos minutos..."):
            # 3. Correr el modelo
            df_resumen, df_global = run_montecarlo_simulation(
                n_replicaciones, min_freq, max_freq, capacidad,
                dwell_time, tiempo_viaje, df_lambda_final, MAPAS_DESCENSO
            )

        st.success("¬°Simulaci√≥n completada!")

        # 4. Mostrar Resultados
        st.header("3. Resultados del Experimento")

        st.subheader("Resumen Estad√≠stico (Agregado de Corridas)")
        st.write(f"Resultados basados en {n_replicaciones} corridas (Escenario Calibrado V4).")
        st.dataframe(df_resumen)

        # 5. Mostrar Gr√°ficos
        st.subheader("Visualizaci√≥n de Cuellos de Botella")

        # Gr√°fico 1: Colas
        df_sorted_colas = df_resumen.sort_values(by='Cola_Max_Promedio', ascending=False)
        st.write("**Gr√°fico 1: Cola M√°xima Promedio por And√©n**")
        st.bar_chart(df_sorted_colas['Cola_Max_Promedio'])

        # Gr√°fico 2: Esperas
        df_sorted_espera = df_resumen.sort_values(by='Espera_Prom_Promedio_Seg', ascending=False)
        st.write("**Gr√°fico 2: Tiempo de Espera Promedio por And√©n**")
        st.bar_chart(df_sorted_espera['Espera_Prom_Promedio_Seg'])

        st.info("Simulaci√≥n finalizada. Pod√©s cambiar los par√°metros de la barra lateral y volver a correr.")