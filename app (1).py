# -*- coding: utf-8 -*-
"""APP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fUoFxHBp4ciGI9TWIntBtmVVOOWnPiBW
"""

import streamlit as st
import pandas as pd
import numpy as np
import simpy
import random
import csv
import matplotlib.pyplot as plt

# --- 0. CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(
    page_title="Simulador Subte L√≠nea D",
    layout="wide"
)

# --- (MODIFICACI√ìN 1) ---
# Pega el link que copiaste de GitHub Releases aqu√≠
DATA_URL = "PEG√Å_TU_LINK_DE_GITHUB_RELEASES_AQU√ç"
# Ejemplo: "https://github.com/tu-usuario/simulador-subte-tpi/releases/download/v1.0/202501_D.csv"
# --- FIN DE MODIFICACI√ìN 1 ---


# --- 1. FUNCIONES DE CARGA Y LIMPIEZA DE DATOS ---

# (MODIFICACI√ìN 2: La funci√≥n ahora lee desde la URL, no desde un 'uploaded_file')
@st.cache_data # st.cache_data es CRUCIAL para que no descargue el archivo 100MB+ cada vez
def load_and_clean_data(url_de_datos):
    """
    Descarga el CSV desde la URL de GitHub Releases
    y realiza toda la limpieza de datos.
    """
    st.info(f"Descargando datos desde la URL... (Esto puede tardar un momento la primera vez)")
    print("Iniciando descarga y limpieza de datos...")

    # --- Carga de Datos ---
    try:
        df = pd.read_csv(
            url_de_datos, # Lee directamente desde la URL
            sep=';',
            encoding='utf-8-sig',
            quoting=csv.QUOTE_NONE,
            low_memory=False
        )
    except Exception as e:
        st.error(f"Error fatal al leer el CSV desde la URL: {e}")
        st.error("Verifica que el link en DATA_URL sea correcto y sea un link de descarga directa.")
        return None, None

    # ... (El resto del c√≥digo de limpieza es ID√âNTICO a antes) ...
    df.columns = df.columns.str.replace('"', '', regex=False).str.strip()
    required_cols = ['FECHA', 'pax_TOTAL', 'ESTACION', 'LINEA', 'MOLINETE', 'DESDE']
    if not all(col in df.columns for col in required_cols):
        st.error(f"Error: El CSV no contiene todas las columnas requeridas: {required_cols}")
        return None, None
    df['FECHA'] = df['FECHA'].astype(str).str.replace('"', '', regex=False).str.strip()
    df['pax_TOTAL'] = df['pax_TOTAL'].astype(str).str.replace('"', '', regex=False).str.strip()
    df['LINEA'] = df['LINEA'].astype(str).str.strip()
    df['ESTACION'] = df['ESTACION'].astype(str).str.strip()
    df_linea_d = df[df['LINEA'] == 'LineaD'].copy()
    df_linea_d['ESTACION'] = df_linea_d['ESTACION'].replace('9 de julio', '9 de Julio')
    df_linea_d['ESTACION'] = df_linea_d['ESTACION'].replace('Ag√É¬ºero', 'Ag√ºero')
    df_linea_d['FECHA'] = pd.to_datetime(df_linea_d['FECHA'], format='%d/%m/%Y')
    df_linea_d['pax_TOTAL'] = pd.to_numeric(df_linea_d['pax_TOTAL'], errors='coerce')
    df_linea_d.dropna(subset=['pax_TOTAL'], inplace=True)
    df_linea_d['pax_TOTAL'] = df_linea_d['pax_TOTAL'].astype(int)

    print("Carga y limpieza de datos completada.")

    # --- (MODIFICACI√ìN 3: Ahora esta funci√≥n tambi√©n calcula Lambda) ---
    print("Iniciando c√°lculo de Lambda...")
    df_linea_d['DIRECCION'] = df_linea_d.apply(asignar_direccion, axis=1)
    df_con_direccion = df_linea_d[df_linea_d['DIRECCION'] != 'Ponderar'].copy()
    df_para_ponderar = df_linea_d[df_linea_d['DIRECCION'] == 'Ponderar'].copy()
    df_ponderar_catedral = df_para_ponderar.copy()
    df_ponderar_congreso = df_para_ponderar.copy()
    df_ponderar_catedral['DIRECCION'] = 'Hacia Catedral'
    df_ponderar_catedral['pax_TOTAL'] = df_ponderar_catedral['pax_TOTAL'] * 0.5
    df_ponderar_congreso['DIRECCION'] = 'Hacia Congreso'
    df_ponderar_congreso['pax_TOTAL'] = df_ponderar_congreso['pax_TOTAL'] * 0.5
    df_direccional = pd.concat([df_con_direccion, df_ponderar_catedral, df_ponderar_congreso], ignore_index=True)
    df_direccional['pax_TOTAL'] = pd.to_numeric(df_direccional['pax_TOTAL'], errors='coerce')
    df_direccional.dropna(subset=['pax_TOTAL'], inplace=True)
    condicion_pico_1hr = (df_direccional['DESDE'] >= '08:00:00') & (df_direccional['DESDE'] < '09:00:00')
    df_pico_direccional = df_direccional[condicion_pico_1hr].copy()
    df_lambda_final = df_pico_direccional.groupby(
        ['ESTACION', 'DIRECCION', 'DESDE']
    )['pax_TOTAL'].mean().reset_index()
    df_lambda_final = df_lambda_final.rename(columns={'pax_TOTAL': 'pasajeros_PROMEDIO_lambda'})
    print("C√°lculo de Lambda completado.")

    return df_lambda_final # <-- Devuelve el DataFrame de Lambda listo

# --- (Funci√≥n 'calculate_lambda' ya no es necesaria, la fusionamos arriba) ---
# --- (Funci√≥n 'asignar_direccion' sigue igual) ---
def asignar_direccion(row):
    estacion = row['ESTACION']
    molinete = str(row['MOLINETE'])
    if estacion == 'Catedral': return 'Hacia Congreso'
    if estacion == 'Congreso de Tucuman': return 'Hacia Catedral'
    if estacion == '9 de Julio': return 'Ponderar'
    if '_N_' in molinete: return 'Hacia Congreso'
    if '_S_' in molinete or '_SO_' in molinete: return 'Hacia Catedral'
    if '_Este_' in molinete or '_E_' in molinete: return 'Hacia Catedral'
    if '_Oeste_' in molinete or '_O_' in molinete: return 'Hacia Congreso'
    return 'Ponderar'

# --- (El resto del c√≥digo de SimPy: CONSTANTES, Clase Anden, Procesos, etc. sigue ID√âNTICO) ---
# ... (copi√° y peg√° toda la secci√≥n 2 y 3 de tu app.py anterior) ...
# ... (Clase Anden, generador_pasajeros, proceso_tren, generador_trenes, run_montecarlo_simulation) ...
LISTA_ESTACIONES_NORTE = [
    'Catedral', '9 de Julio', 'Tribunales', 'Callao', 'Facultad de Medicina',
    'Ag√ºero', 'Pueyrredon.D', 'Bulnes', 'Plaza Italia', 'Ministro Carranza',
    'Olleros', 'Jose Hernandez', 'Juramento', 'Congreso de Tucuman'
]
LISTA_ESTACIONES_SUR = LISTA_ESTACIONES_NORTE[::-1]
TIEMPO_SIMULACION_SEG = 3600 # 1 Hora
INTERVALO_LAMBDA_SEG = 900 # 15 min
TASAS_DESCENSO_HACIA_CATEDRAL_V2 = {
    'Congreso de Tucuman': 0.0, 'Juramento': 0.05, 'Jose Hernandez': 0.05, 'Olleros': 0.05,
    'Ministro Carranza': 0.20, 'Plaza Italia': 0.05, 'Bulnes': 0.05,
    'Pueyrredon.D': 0.25, 'Ag√ºero': 0.10, 'Facultad de Medicina': 0.15, 'Callao': 0.20,
    'Tribunales': 0.30, '9 de Julio': 0.40, 'Catedral': 1.0
}
TASAS_DESCENSO_HACIA_CONGRESO_V4 = {
    'Catedral': 0.0, '9 de Julio': 0.30, 'Tribunales': 0.25, 'Callao': 0.25,
    'Facultad de Medicina': 0.20, 'Ag√ºero': 0.20, 'Pueyrredon.D': 0.35,
    'Bulnes': 0.25, 'Plaza Italia': 0.35, 'Ministro Carranza': 0.35,
    'Olleros': 0.25, 'Jose Hernandez': 0.25, 'Juramento': 0.30,
    'Congreso de Tucuman': 1.0
}
MAPAS_DESCENSO = {
    "Hacia Catedral": TASAS_DESCENSO_HACIA_CATEDRAL_V2,
    "Hacia Congreso": TASAS_DESCENSO_HACIA_CONGRESO_V4
}
class Anden:
    def __init__(self, env, nombre_estacion, direccion):
        self.env = env
        self.nombre = f"{nombre_estacion}_{direccion}"
        self.direccion = direccion
        self.estacion_nombre = nombre_estacion
        self.cola_pasajeros = simpy.Store(env)
        self.metricas_tiempo_espera = []
        self.metricas_cola_por_tren = []
    def add_pasajero(self, pasajero):
        pasajero['tiempo_llegada_anden'] = self.env.now
        return self.cola_pasajeros.put(pasajero)
    def tren_llega_a_anden(self, tren, dwell_time):
        pasajeros_en_cola_al_llegar = len(self.cola_pasajeros.items)
        self.metricas_cola_por_tren.append(pasajeros_en_cola_al_llegar)
        pasajeros_subidos = 0
        while tren['pasajeros_actuales'] < tren['capacidad'] and len(self.cola_pasajeros.items) > 0:
            pasajero = yield self.cola_pasajeros.get()
            tiempo_espera = self.env.now - pasajero['tiempo_llegada_anden']
            self.metricas_tiempo_espera.append(tiempo_espera)
            tren['pasajeros_actuales'] += 1
            pasajeros_subidos += 1
        yield self.env.timeout(dwell_time)
def generador_pasajeros(env, anden, df_lambda, intervalo_seg):
    lambda_data = df_lambda[
        (df_lambda['ESTACION'] == anden.estacion_nombre) &
        (df_lambda['DIRECCION'] == anden.direccion)
    ].set_index('DESDE')
    intervalos = ['08:00:00', '08:15:00', '08:30:00', '08:45:00']
    for intervalo_hora in intervalos:
        lambda_actual = 0.0
        try: lambda_actual = lambda_data.loc[intervalo_hora]['pasajeros_PROMEDIO_lambda']
        except KeyError: pass
        if lambda_actual > 0:
            seg_entre_pasajeros = intervalo_seg / lambda_actual
            inicio_intervalo = env.now
            while env.now < inicio_intervalo + intervalo_seg:
                tiempo_llegada_prox_pax = random.expovariate(1.0 / seg_entre_pasajeros)
                yield env.timeout(tiempo_llegada_prox_pax)
                if env.now < inicio_intervalo + intervalo_seg:
                    pasajero = {'id': f"pax_{random.randint(1000,9999)}"}
                    yield anden.add_pasajero(pasajero)
        else:
            yield env.timeout(intervalo_seg)
def proceso_tren(env, tren_id, lista_recorrido, tiempo_viaje, dwell_time, capacidad, mundo_andenes, tasas_descenso):
    tren = {'id': tren_id, 'capacidad': capacidad, 'pasajeros_actuales': 0}
    direccion_viaje = "Hacia Congreso" if lista_recorrido == LISTA_ESTACIONES_NORTE else "Hacia Catedral"
    for i, nombre_estacion in enumerate(lista_recorrido):
        if i > 0:
            yield env.timeout(tiempo_viaje)
        nombre_anden = f"{nombre_estacion}_{direccion_viaje}"
        anden_actual = mundo_andenes[nombre_anden]
        if tren['pasajeros_actuales'] > 0:
            tasa_bajada = tasas_descenso[nombre_estacion]
            pasajeros_que_bajan = np.random.binomial(tren['pasajeros_actuales'], tasa_bajada)
            tren['pasajeros_actuales'] -= pasajeros_que_bajan
        yield env.process(anden_actual.tren_llega_a_anden(tren, dwell_time))
def generador_trenes(env, direccion, lista_recorrido, min_freq, max_freq, tiempo_viaje, dwell_time, capacidad, mundo_andenes, tasas_descenso):
    tren_id_counter = 0
    while True:
        frecuencia = random.uniform(min_freq, max_freq)
        yield env.timeout(frecuencia)
        tren_id_counter += 1
        tren_id = f"Tren_{direccion}_{tren_id_counter}"
        env.process(proceso_tren(env, tren_id, lista_recorrido, tiempo_viaje, dwell_time, capacidad, mundo_andenes, tasas_descenso))
def run_montecarlo_simulation(n_replicaciones, min_freq, max_freq, capacidad, dwell_time, tiempo_viaje, df_lambda, mapas_descenso):
    print(f"Iniciando Montecarlo con {n_replicaciones} r√©plicas...")
    lista_de_resultados_global = []
    progress_bar = st.progress(0) # Barra de progreso de Streamlit

    for i in range(n_replicaciones):
        semilla_actual = i + 1
        #print(f"Corriendo R√©plica {semilla_actual}/{n_replicaciones}...")
        random.seed(semilla_actual)
        np.random.seed(semilla_actual)
        env = simpy.Environment()
        mundo_andenes = {}
        for estacion in LISTA_ESTACIONES_NORTE:
            anden_norte = Anden(env, estacion, "Hacia Congreso")
            mundo_andenes[anden_norte.nombre] = anden_norte
            anden_sur = Anden(env, estacion, "Hacia Catedral")
            mundo_andenes[anden_sur.nombre] = anden_sur
        for anden_obj in mundo_andenes.values():
            env.process(generador_pasajeros(env, anden_obj, df_lambda, INTERVALO_LAMBDA_SEG))
        env.process(generador_trenes(
            env, "Hacia_Congreso", LISTA_ESTACIONES_NORTE, min_freq, max_freq,
            tiempo_viaje, dwell_time, capacidad, mundo_andenes,
            mapas_descenso["Hacia Congreso"]
        ))
        env.process(generador_trenes(
            env, "Hacia_Catedral", LISTA_ESTACIONES_SUR, min_freq, max_freq,
            tiempo_viaje, dwell_time, capacidad, mundo_andenes,
            mapas_descenso["Hacia Catedral"]
        ))
        env.run(until=TIEMPO_SIMULACION_SEG)
        for anden_obj in mundo_andenes.values():
            t_espera = anden_obj.metricas_tiempo_espera
            l_cola = anden_obj.metricas_cola_por_tren
            lista_de_resultados_global.append({
                'Anden': anden_obj.nombre,
                'Replica': semilla_actual,
                'Tiempo_Espera_Promedio_Seg': np.mean(t_espera) if len(t_espera) > 0 else 0,
                'Cola_Maxima_VISTA': np.max(l_cola) if len(l_cola) > 0 else 0
            })

        # Actualizar barra de progreso
        progress_bar.progress((i + 1) / n_replicaciones)

    print("Montecarlo terminado. Analizando resultados...")
    df_global_stats = pd.DataFrame(lista_de_resultados_global)
    df_resumen_estadistico = df_global_stats.groupby('Anden').agg(
        Cola_Max_Promedio=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='mean'),
        Cola_Max_Min=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='min'),
        Cola_Max_Max=pd.NamedAgg(column='Cola_Maxima_VISTA', aggfunc='max'),
        Espera_Prom_Promedio_Seg=pd.NamedAgg(column='Tiempo_Espera_Promedio_Seg', aggfunc='mean'),
        Espera_Prom_Max_Seg=pd.NamedAgg(column='Tiempo_Espera_Promedio_Seg', aggfunc='max')
    ).sort_values(by='Cola_Max_Promedio', ascending=False)

    return df_resumen_estadistico, df_global_stats


# --- 4. INTERFAZ DE USUARIO (STREAMLIT) ---

st.title("üöá Simulador de la L√≠nea D (Modelo TPI)")
st.write("Esta app ejecuta un modelo de Simulaci√≥n de Eventos Discretos (SimPy) para la L√≠nea D, basado en el TPI.")

# --- Barra Lateral (Sidebar) para Par√°metros ---
st.sidebar.header("Par√°metros de Simulaci√≥n üõ†Ô∏è")
n_replicaciones = st.sidebar.slider(
    "N¬∞ de Corridas (Montecarlo)", min_value=1, max_value=100, value=50, step=1,
    help="N√∫mero de veces que se corre la simulaci√≥n (con diferentes semillas) para obtener un resultado estad√≠stico."
)
st.sidebar.subheader("Par√°metros de Oferta (Tren)")
capacidad = st.sidebar.slider(
    "Capacidad del Tren (Pasajeros)", min_value=1000, max_value=2000, value=1500, step=50,
    help="Capacidad m√°xima ('de estr√©s') de un convoy."
)
min_freq = st.sidebar.slider(
    "Frecuencia M√≠nima (Segundos)", min_value=60, max_value=300, value=120, step=10,
    help="Tiempo m√≠nimo (en segundos) que tarda en salir un tren de la terminal (ej. 120s = 2 min)."
)
max_freq = st.sidebar.slider(
    "Frecuencia M√°xima (Segundos)", min_value=120, max_value=360, value=180, step=10,
    help="Tiempo m√°ximo (en segundos) que tarda en salir un tren (ej. 180s = 3 min)."
)
dwell_time = st.sidebar.slider(
    "Tiempo de Detenci√≥n (Segundos)", min_value=15, max_value=60, value=30, step=1,
    help="Tiempo (en segundos) que el tren permanece detenido en cada estaci√≥n (Dwell Time)."
)
tiempo_viaje = st.sidebar.slider(
    "Tiempo de Viaje (Segundos)", min_value=60, max_value=180, value=120, step=5,
    help="Tiempo (en segundos) que tarda el tren en viajar entre una estaci√≥n y la siguiente."
)


# --- (MODIFICACI√ìN 4) ---
# Quitamos el file_uploader y cargamos los datos desde la URL
st.header("1. Cargar Datos y Ejecutar Simulaci√≥n")
st.write("El modelo est√° configurado para descargar los datos de demanda (Enero) desde GitHub.")

df_lambda_final = load_and_clean_data(DATA_URL)

if df_lambda_final is not None:
    st.success("Datos de Lambda (Œª) cargados y procesados exitosamente.")
    st.write("Vista previa de la demanda (Tasa Lambda Œª):")
    st.dataframe(df_lambda_final.head())

    # 2. Bot√≥n para correr la simulaci√≥n
    if st.button("‚ñ∂Ô∏è Correr Simulaci√≥n (Escenario Montecarlo)"):

        with st.spinner(f"Ejecutando {n_replicaciones} corridas... Esto puede tardar uno o dos minutos..."):
            df_resumen, df_global = run_montecarlo_simulation(
                n_replicaciones, min_freq, max_freq, capacidad,
                dwell_time, tiempo_viaje, df_lambda_final, MAPAS_DESCENSO
            )

        st.success("¬°Simulaci√≥n completada!")

        # 3. Mostrar Resultados
        st.header("2. Resultados del Experimento")
        st.subheader("Resumen Estad√≠stico (Agregado de Corridas)")
        st.write(f"Resultados basados en {n_replicaciones} corridas (Escenario Calibrado V4).")
        st.dataframe(df_resumen)

        # 4. Mostrar Gr√°ficos
        st.subheader("Visualizaci√≥n de Cuellos de Botella")
        df_sorted_colas = df_resumen.sort_values(by='Cola_Max_Promedio', ascending=False)
        st.write("**Gr√°fico 1: Cola M√°xima Promedio por And√©n**")
        st.bar_chart(df_sorted_colas['Cola_Max_Promedio'])

        df_sorted_espera = df_resumen.sort_values(by='Espera_Prom_Promedio_Seg', ascending=False)
        st.write("**Gr√°fico 2: Tiempo de Espera Promedio por And√©n**")
        st.bar_chart(df_sorted_espera['Espera_Prom_Promedio_Seg'])

        st.info("Simulaci√≥n finalizada. Pod√©s cambiar los par√°metros de la barra lateral y volver a correr.")
else:
    st.error("No se pudieron cargar los datos de Lambda. Revisa el link en DATA_URL.")
# --- FIN DE MODIFICACI√ìN 4 ---